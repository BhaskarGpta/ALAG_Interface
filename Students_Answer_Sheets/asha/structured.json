{
    "answers": [
        {
            "question_number": 1,
            "question_text": "What is a Python virtual environment, and why is it important? [Marks 5]",
            "student_answer": ""
        },
        {
            "question_number": 2,
            "question_text": "What are the key differences between lists, tuples, sets, and dictionaries in Python? [Marks 5]\\n\\nDiscuss the characteristics (mutability, indexing, ordering, etc.) of each data structure",
            "student_answer": "Key differences between lists, tuples, sets, dictionaries\\n\\nList:\\n- A list is an ordered, mutable collection of elements that can store multiple data types.\\nSyntax:\\nList_name = [elem1, elem2, elem3, ...]\\nE.g.:\\nmy_list = [1, 2, 3, 'Asha', 'Lalam']\\nmy_list.append('Abhi')\\nmy_list[0] = 100\\nPrint(my_list)\\nOutput:\\n[100, 2, 3, 'Asha', 'Lalam', 'Abhi']\\n\\nList is mutable.\\nList maintains order of elements as inserted.\\nAllow duplicates.\\nList elements accessed using indices.\\nDenoted as []\\nMethods include such as append(), remove(), sort(), pop(), etc.\\n\\nTuple:\\n- Tuple is ordered, immutable, collection of elements that can store multiple data types.\\nSyntax:\\ntuple_name = (elem1, elem2, elem3, ...)\\nE.g.:\\ndemo = (1, 2, 3, 'Asha', 'Abhi')\\nPrint(demo[2])\\nOutput:\\n3\\n\\nTuple is immutable.\\nIt maintains order of elements.\\nAllows duplicates.\\nAccessed using indices.\\n\\nset: It is unordered, mutable collection of unique elements\\nSyntax: setname = {ele1, ele2, ele3, ...}\\neg: Demo = {1, 2, 3, 'Asha', 'Abhi'}\\nDemo.add('Thanuja')\\nDemo.remove(1)\\nprint(Demo)\\nOutput: {1, 'Asha', 'Abhi', 2, 3, 'Thanuja'}\\nOrder of output varies each time\\n* No duplicates allowed\\n* Can access elements using indexing\\nOperations: Union, Intersection, Difference\\n\\nDictionary\\nIt is an unordered, mutable\\n-> Collection of Key-Value pairs\\nSyntax: dictname = {key: value, key: value, ...}\\neg: cong = {'Name': 'Asha', 'Age': 20, 'Branch': 'CSE'}\\nprint(cong['Name'])\\nOutput: Asha\\n-> Keys and values can be modified after creation\\n-> Keys are unique\\n-> Values can be duplicated\\n-> Unordered\\n-> We can access via keys\\n-> Methods:\\n    keys()\\n    values()\\n    items()\\n    get()\\n    pop()\\n-> Used for mapping data using keys and values for fast lookups"
        },
        {
            "question_number": 3,
            "question_text": "What are string slicing and string formatting in Python? Provide examples. [Marks 5]",
            "student_answer": "String Slicing & String Formatting\\n\\nString Slicing\\n- It is a technique in Python used to extract a substring by specifying a range of indices.\\nSyntax:\\nstring[start:end:step]\\n- start -> starting index (inclusive)\\n- end -> ending index (exclusive)\\n- step -> size of step\\n- default step size is 1\\n\\nExample:\\neg = 'Asha, Abhi!'\\nprint(eg[0:5])\\nOutput: Asha\\n\\nprint(eg[:5]) -> Asha  # start to 5\\nprint(eg[7:]) -> Abhi!  # 7 to end\\nprint(eg[-5:]) -> Abhi!  # from backward\\nprint(eg[::2]) -> Asbi\\n\\n- Strings are immutable: slicing creates a new string\\n\\nString Formatting\\n- It allows you to dynamically insert variable values and expressions into strings.\\n- Using methods of string formatting\\n  - Using % operator\\n  - Using str.format() method\\n  - Using f-strings\\n\\nExample:\\nname = 'Asha'\\nage = 18\\nprint('My name is %s & I'm %d years.' % (name, age))\\nOutput: My name is Asha & I'm 18 years.\\n\\nUsing str.format() method\\n\\n```python\\nname = 'Asha'\\nage = 20\\nprint('I am {} years old, name is {}'.format(name, age))\\n```\\n\\nOutput: I am 20 years old, name is Asha\\n\\nUsing f-strings\\n\\n```python\\nname = 'Asha'\\nage = 20\\nprint(f'Next year, I will be {age + 1} years old.')\\n```\\n\\nNext year, I will be 21 years old.\\n\\n| Features | String Slicing | String Formatting |\\n|----------|----------------|-------------------|\\n| Purpose  | Extract substring from string | Insert variable values into string |\\n| Mutability | Immutable | Immutable |\\n| Use Case | Works with parts of string | Create dynamic readable string |\\n| Ease of use | Straightforward with steps | Easy with f-string |"
        },
        {
            "question_number": 4,
            "question_text": "How does SciPy extend NumPy for scientific computing? Mention at least two features provided by SciPy. [Marks 5]",
            "student_answer": ""
        },
        {
            "question_number": 5,
            "question_text": "What is the Seaborn library used for, and how does it differ from Matplotlib? [Marks 5]",
            "student_answer": ""
        },
        {
            "question_number": 6,
            "question_text": "Explain inheritance in Python and provide an example of how a child class can inherit properties and methods from a parent class. [Marks 5]",
            "student_answer": "Inheritance\\nInheritance is a fundamental concept in OOP that allows a class to inherit attributes and methods from another class.\\n- It promotes code reusability\\n- Code extensibility\\n- Easier to modify\\n\\nInheriting/deriving properties from base class to subclass\\n\\nBase class -> parent/superclass\\nChild class -> derived/subclass\\n\\nTypes\\n1. Single inheritance\\n- 1 child class inherits from one parent class\\n\\nExample:\\n```python\\nclass Parent:\\n    # body\\n\\nclass Child(Parent):\\n    # body\\n```\\n\\nExample:\\n```python\\nclass Parent:\\n    print('Parent class')\\n\\nclass Child(Parent):\\n    print('Child class')\\n\\nc = Child()\\n```\\n\\n2. Multiple inheritance\\n- A class (child) inherits from multiple parent classes\\n\\nExample:\\n```python\\nclass Parent:\\n    # body\\n\\nclass Parent2:\\n    # body\\n\\nclass Child(Parent, Parent2):\\n    # body\\n```\\n\\nmultilevel inheritance: A class inherits from another derived class\\n\\n```\\nA\\nB\\nC\\n```\\n\\nSyntax:\\n```\\nclass Parent:\\n    # body\\n\\nclass Child(Parent):\\n    # body\\n\\nclass Baby(Child):\\n    # body\\n```\\n\\nhierarchical inheritance: multiple classes inherit from the same parent class\\n\\n```\\nA\\nB C D\\n```\\n\\nSyntax:\\n```\\nclass Parent:\\n    # body\\n\\nclass Child1(Parent):\\n    # body\\n\\nclass Child2(Parent):\\n    # body\\n\\nclass Child3(Parent):\\n    # body\\n```\\n\\nTypes of inheritance\\n\\n1. Single\\n2. Multilevel\\n3. Multiple\\n4. Hierarchy\\n\\nClass parent:\\ndef disp(self):\\n    print('Parent class')\\n\\nClass child(parent):\\ndef dispchild(self):\\n    print('This is child class')\\n\\ni = child()\\ni.disp()\\ni.dispchild()\\n\\nClass father:\\ndef output(self):\\n    print('Base class')\\n\\nClass mother:\\ndef outputm(self):\\n    print('Mother class')\\n\\nClass child(father, mother):\\ndef outputc(self):\\n    print('Child class')\\n\\ni = child()\\ni.output()\\ni.outputm()\\ni.outputc()\\n\\nClass father:\\ndef op(self):\\n    print('Father class')\\n\\nClass child1(father):\\ndef opc(self):\\n    print('Child1 class')\\n\\nClass child2(father):\\ndef op2(self):\\n    print('Child2 class')\\n\\nClass child3(father):\\ndef op3(self):\\n    print('Child3 class')\\n\\nClass Gf:\\ndef disp(self):\\n    print('Gf')\\n\\nClass father(Gf):\\ndef dispf(self):\\n    print('Father')\\n\\nClass child(father):\\ndef disp(self):\\n    print('Child')\\n\\ni = child()\\ni.disp()\\ni.dispf()\\ni.disp()\\n\\nFlexibility\\nReusability\\nExtensibility\\nTime Saving\\n\\nC1 = father()\\nC2 = father()\\nC3 = father()\\nC1.op()\\nC2.op()\\nC3.op()"
        }
    ]
}